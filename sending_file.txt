% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{longtable,booktabs,array}
\usepackage{multirow}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\usepackage[normalem]{ulem}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\author{}
\date{}

\begin{document}

Assignment 4: TCP-like UDP

COL 334/672, Diwali'24

\begin{quote}
October 16, 2024\\
Deadline: October 30, 2024

\textbf{Goal}: In this assignment, you will implement a simple file
transfer protocol using UDP sock-ets. Since UDP (User Datagram Protocol)
is unreliable and does not provide congestion control, you will design
and implement mechanisms to ensure reliability and congestion control at
the application layer.

\textbf{Overview}: You will be tasked with creating a client-server
application where the client down-loads a pre-specified file from the
server using UDP. The client and server should implement:

• Reliability: Ensure that all packets are delivered to the client in
the correct order and without loss.

• Congestion Control: Implement a congestion control algorithm to
prevent overwhelming the network. You will implement TCP Reno and CUBIC
(if you attempt the bonus part).

\textbf{General Instructions}

• Any instance of cheating will receive strict penalty.

• You are allowed to do this assignment in a pair.

• You will need Mininet and Ryu controller for the analysis part in this
section. You can re-use the installation that you used in Assignment 3.

• You should submit a single zipped folder containing all the code as
well as the report. Name it
\textless entryno1\textgreater\textless entryno2\textgreater.zip, i.e.,
the names of your and your partner's entry number. \emph{Please note:
Only one submission per group is required.}

• \textbf{Piazza protocols}: We will follow the following Piazza
protocols like last time:

\textbf{-- Piazza protocol 0}: You are encouraged to ask questions on
Piazza.

\textbf{-- Piazza protocol 1}: Each \emph{new} question should be asked
in a separate thread with a \textbf{clear} subject line. Using a
descriptive subject line is helpful to everyone.

\textbf{-- Piazza protocol 2}: \emph{Please ask questions in advance.}
Not all questions that are asked within 2 days of the deadline may be
answered. No questions will be answered after the deadline.

\textbf{1 Part 1: Reliability (40\%)}

Since UDP does not guarantee reliability, you will implement the
following mechanisms to ensure reliable data transmission:

• \textbf{Acknowledgments (ACKs)}: The client uses ACKs to intimate the
server about the successful delivery of a message. You should implement
cumulative ACKs. Feel free to use delayed ACKs if you find that improves
the efficiency.

• \textbf{Retransmissions}: If the server does not receive an ACK within
a specified timeout period or detects 3 duplicate ACKs, it should
retransmit the packet.
\end{quote}

1

\begin{quote}
• \textbf{Fast Recovery}: The server should implement a fast recovery
mechanism that initiates retransmission upon receiving 3 duplicate ACKs.

• \textbf{Packet Numbering}: Each packet sent by the server should
include a sequence number. The client will use these sequence numbers to
reconstruct the file in the correct order.

• \textbf{Timeout Mechanism}: The server should implement a timeout
mechanism to trigger re-transmissions of unacknowledged packets. The
timeout value should be estimated using the method discussed in class.
If you are using another method, please mention that in your report.

You can implement reliability only for server-client communication. For
the initial client-server communication, you can simply keep re-trying
until the request for file download is successfully delivered. You can
assume the server is handling only one client.

\textbf{1.1 Packet Format}

While TCP uses a 32-bit integer to represent packet sequence number, in
this assignment, we will assume that sequence numbers can be arbitrarily
large. For us, the first byte will start with a sequence number of zero
and the rest increment from there. Thus, a data packet contain the
following fields: sequence number of the first byte, number of data
bytes, the data. Moreover, we will serialize information using json to
keep debugging and serializing/deserializing simple. You are free to use
your own identifier for these fields.

Acknowledgement packets simply contain the next expected sequence
number, indicating the sender that all bytes before this sequence number
have been received.

\textbf{1.2 Analysis}

You should empirically measure the performance improvements due to fast
re-transmissions by conducting the following analysis:

• \textbf{Setup}: Run a simple two-node topology in Mininet, provided
along with this assignment. It consists of two hosts (h1 and h2)
connected via a switch (s1). Use a Ryu controller application running a
simple learning switch to set up the forwarding tables on the switch.
Use your program that implements reliability but no congestion control
to transfer a file between the client and server. Use a a fixed rate of
50 Mbps to send the packets.

• \textbf{Experiments}: Conduct two sets of experiments: one measuring
the improvement due to fast recovery under varying loss conditions, and
another measuring the improvement with varying delay. For the loss
experiments, set a fixed delay of 20 ms on the h1-s1. link and vary the
loss rate from 0\% to 5\%, in increments of 0.5\%. For the delay
experiments, set a fixed packet loss rate of 1\% on the h1-s1 link and
vary the delay from 0 to 200 ms, in increments of 20 ms. In both cases,
set the loss and delay for the h2-s2 link to 0. \textbf{Data
Collection}: For each experiment, log the time taken to download the
file. Repeat each experiment 5 times to account for noise.

• \textbf{Plotting Results}: For the loss experiments, create a line
plot comparing the file trans-mission time with and without fast
recovery as the loss varies. Similarly, generate a plot for the delay
experiments, comparing the transmission times as delay changes. Explain
the observed trends in the results in the report.

\textbf{1.3 What to submit}

Submit the client file and server file, naming them p1client.py and
p1server.py. We should be able to run the code as follows:

Running server: python3 p1\_server.py \textless SERVER\_IP\textgreater{}
\textless SERVER\_PORT\textgreater{}
\textless FAST\_RECOVERY\_BOOL\textgreater{} Running client: python3
p1\_client.py \textless SERVER\_IP\textgreater{}
\textless SERVER\_PORT\textgreater{}
\end{quote}

2

\begin{quote}
Here, SERVERIP and SERVERPORT represent the IP address and port that the
server is listening on. The FASTRECOVERYBOOL indicates whether fast
recovery is enabled, with a value of 1 meaning it is on and 0 meaning it
is off.

In addition, add the plot and your explanation in the report.

\textbf{2 Part 2: Congestion Control (60\%)}

You will implement a congestion control algorithm based on a sliding
window approach, i.e., the client should send multiple packets without
waiting for an ACK for each one. However, the number of packets (window
size) should be controlled to avoid overwhelming the network. You should
implement TCP Reno-like congestion control. In particular, you should
implement the following mechanisms:

• \textbf{Slow-start}: Exponentially increase the congestion window
(cwnd) size (double every RTT) until it reaches a threshold or detects
packet loss.

• \textbf{Congestion avoidance}: When cwnd exceeds the slow start
threshold, TCP Reno increases the window size linearly to avoid
congestion.

• \textbf{Fast recovery}: After detecting 3 duplicate ACKs, halve the
cwnd and perform linear growth (1 MSS every RTT) to quickly recover from
minor congestion.

• \textbf{Timeout behavior}: If a timeout occurs, reset cwnd to 1 and
initiate slow start, assuming severe congestion.

Please refer to TCP Reno for any missing details. For instance, you
should dynamically update the slow start threshold as done in TCP Reno.

\textbf{2.1 Implementation details}

• You should implement the congestion control mechanisms on top of the
code that implements reliability in Part 1.

• Assume the same format of the packet as specified in Part 1.

• You should start with an initial window of 1 MSS. Assume an MSS is
1400 bytes.

• Use an additive increase factor of 1 MSS and multiplicate decrease
factor of 0.5.

• No need to implement flow control.

\textbf{2.2 Analysis}

\textbf{1. Efficiency}: In this set of experiments, you should measure
the impact of varying delay and packet loss on TCP throughput. Use a
similar 2-node topology as in Part 1. In the first set of experiments,
you should vary the link delay as done in Part 1 and log the average
throughput. You should plot the average throughput as a function of link
delay. Repeat the experiments with loss using similar setup as described
in Part 1. Plot the average throughput as a function of packet 1\\
loss. Related literature suggests that throughput \emph{∝RT T ×√p},
where p is the packet loss rate. Do you observe similar results? Explain
your observation in both cases.

\textbf{2. Fairness}: In this experiment, we will evaluate the fairness
of the developed congestion control algorithm. Particularly, we will
conduct experiment with a dumbbell topology consisting of two pairs of
clients and servers, sharing a bottleneck link as shown in Figure 1. You
should vary the link delay of Switch2-Server2 link from 0 ms to 50 ms at
5 ms intervals. Run the client and server program on both client-server
pairs and log the observed throughput for both. Plot the Jain's fairness
index as a function of link latency. Explain your observations.
\end{quote}

3

\includegraphics[width=2.93472in,height=0.91944in]{vertopal_a0b397b5866e4de6b5f9cb89391f7f65/media/image1.png}

Figure 1: Dumbbell topology for Experiment 2 in Part 2

\begin{quote}
\textbf{2.3 What to submit}

Submit the client and server file, naming them p2client.py and
p2server.py. We should be able to run the code as follows:

Running server: python3 p2\_server.py \textless SERVER\_IP\textgreater{}
\textless SERVER\_PORT\textgreater{} Running client: python3
p2\_client.py \textless SERVER\_IP\textgreater{}
\textless SERVER\_PORT\textgreater{}

In addition, add the plot and your explanation in the report.

\textbf{3 Part 3: Bonus (20\%)}

Implement TCP CUBIC congestion control algorithm as discussed in class.
More specifically, use the following cubic function for window increase:
\end{quote}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}@{}}
\toprule()
\multicolumn{2}{@{}>{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.3333} + 2\tabcolsep}}{%
\multirow{3}{*}{\begin{minipage}[b]{\linewidth}\raggedright
\begin{quote}
Here, \emph{K} =
\end{quote}
\end{minipage}}} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\begin{quote}
\emph{W}(\emph{t}) = \emph{C}(\emph{t −K})3+ \emph{Wmax}
\end{quote}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
(1)
\end{minipage} \\
& & \multirow{2}{*}{\begin{minipage}[b]{\linewidth}\raggedright
3
\end{minipage}} & \begin{minipage}[b]{\linewidth}\raggedright
\emph{W\uline{max}β}
\end{minipage} &
\multirow{3}{*}{\begin{minipage}[b]{\linewidth}\raggedright
. Use \emph{β} = 0\emph{.}5 and \emph{C} = 0\emph{.}4
\end{minipage}} &
\multirow{3}{*}{\begin{minipage}[b]{\linewidth}\raggedright
\end{minipage}} \\
& & & \begin{minipage}[b]{\linewidth}\raggedright
\emph{C}
\end{minipage} \\
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{3.1}
\end{minipage} &
\multicolumn{3}{>{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.5000} + 4\tabcolsep}}{%
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Analysis}
\end{minipage}} \\
\midrule()
\endhead
\bottomrule()
\end{longtable}

\begin{quote}
\textbf{1. Efficiency:} Repeat the efficiency experiments as with TCP
Reno. Compare the throughput of TCP CUBIC with what was observed for TCP
Reno and explain your observations.

\textbf{2. Fairness:} Use a dumbbell topology with two client-server
pairs. One of the server (S1) runs TCP Reno CCA while the other server
(S2) runs TCP CUBIC CCA. Start both the instances of client-server
pairs. Log the throughput observed over time for each CCA and plot it in
a graph with y-axis representing the CCA throughput and x-axis
representing the time. You should run this experiment with two set of
delay parameters: 1). short delay path, use a delay value of 2 ms for
each link, and 2). long delay path, use a delay value of 25 ms for each
link. Compare the fairness observed in both set of experiments and
explain your observations.
\end{quote}

4

\end{document}
